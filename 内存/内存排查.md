### 1 jstack 分析 CPU 问题

`ps -ef|grep java` 

找到 pid



`top -H -p pid`

找到 CPU 使用率比较高的一些线程



`printf '%x\n' pid` 

得到 nid



 jstack pid |grep 'nid' -C10

在 jstack 中找到相应的堆栈信息



`jstack 90133 > ./jstack.log`

保存到文件中



我们比较关注 WAITING，TIMED_WAITING 和 BLOCKED

`cat jstack.log | grep "java.lang.Thread.State" | sort -nr | uniq -c`



## 2 频繁 GC

`jstat -gc pid 1000`

GC 分代变化情况进行观察 1000 表示采样间隔（ms）

S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU 

分别代表两个 Survivor 区、Eden 区、老年代、元数据区的容量和使用量

YGC/YGT、FGC/FGCT、GCT

则代表 YoungGc、FullGc 的耗时和次数以及总耗时



### 3 上下文切换

`vmstat 1`

 vmstat 命令来进行查看上下文频繁问题 cs（context switch）一列则代表了上下文切换的次数

![](img\cs.PNG)



希望对特定的 pid 进行监控那么可以使用 pidstat -w pid 命令

cswch 和 nvcswch 表示自愿及非自愿切换

`pidstat -w pid`

![](img\640.webp)





### 4 磁盘

查看文件系统状态:

 `df -hl`



性能上分析：

 `iostatiostat -d -k -x`

最后一列 %util 可以看到每块磁盘写入的程度，而 rrqpm/s 以及 wrqm/s 分别表示读写速度

![](img\12.webp)

iotop 命令定位文件读写的来源

上面得到的是tid 转换成 pid --  readlink 来找到 pid

`readlink -f /proc/*/task/tid/../..`

得到 pid

![](img\13.webp)



看这个进程具体的读写情况

`cat /proc/pid/io`

![](img\14.webp)







还可以通过 lsof 命令来确定具体的文件读写情况

 `lsof -p pid`



### 5 堆内内存







