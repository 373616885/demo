### HashMap 

HashMap 数组 + 链表 + 红黑树 ，大小是2的指数幂的数据结构

- 它是根据key的hash对长度取余的找到数组存放的位置
- 如果发送index冲突，则在数组后面使用链表存放
- 当数据大于64个，节点大于8的时候会变成红黑树，小于6转回链表

### 扩容机制

默认大小16 个，负载因子0.75 ，阈值 16* 0.75 =12

当数据大小大于这个阈值就会扩容



### 为什么线程不安全

（1）HashMap 的 size 属性--非典型状况size()的值不准确

这个属性并没有 加上  **volatile **关键字修饰  ,里面的size和size++ 都有并发问题

（2）resize()方法在高并发的情况下，数据丢失的情况

插入元素的时候，hash碰撞了，导致了线程B插入的数据被线程A覆盖了



1.7 之前 node节点采用的头插法   ，并发会发送生死循环

在resize () transfor() 里面

1.8 采用尾插法，解决这个问题

e.next 插入新节点，新的节点的next永远是null，但会造成数据丢失



### 为什么 HashMap的容量永远是2的指数幂

1. 计算方便 hash%n  取模 运算的等价 (n - 1) & hash
2. 扩容时方便计算 ,2的幂次方*2 扩容 ,新元素的位置，要么原位置，要么  原位置 + 原来数据连大小
3. （n-1)就为奇数，结尾1 ，减少hash，冲突，偶数2进制的结尾都是0，那么尾数为1 的hash节点永远无法被使用



###  为什么Hash 算法要与高16位进行异或算法

因为 hash 取余算法 取决于length 的变成2进制的低 n 位

为了让其参与运算 使其更加散列 -- 让高16位和低16位进行异或算法使其参与其中

为什么是异或运算呢？与运算和或运算 得到的结果都是各75% 只有异或算法结果才是各 50%  



### 为什么负载因子是0.75

对空间利用率和时间来讲，0.75是平衡点

空间大，冲突少点，时间快点，但空间利用率不高

空间小，冲突多，时间慢



### HashMap 如果key为null，存放的位置

HashMap 可以允许存放key值为null，存放在数组第0个位置



### ConcurrentHashMap（肯课为HashMap）如何保证线程安全

使用3个CAS操作来确保node的一些操作的原子性

- tabAt ：获取数组指定下标位置的元素
- casTabAt ：用cas的方式去table的指定位置设置值,设置成功返回true
- setTabAt ：用指定位置设置值

上锁的时候用的 synchronized 对每个数组的头节点上锁

总结：用cas和 synchronized 来保证并发



concurrenthashmap 有很多 segments （段）每次统计size 就将这些segments 的 count加起来

还有 modCount，当segment有任何操作就 +1 ,只增不减（防止一个加一个减），遍历两次用于判断有没有写入操作

1. 第一次遍遍历segments数组，将每个segemnt的count加起来作为总数
2. 同时期间把每个segment的modCount加起来sum作为结果是否被修改的判断依据
3. 第二次遍历了两次所有的Segments，每次记录Segment的modCount值，然后将两次的modCount进行比较
4. 如果相同，则返回第一次遍历的结果
5. 如果不同，segment全部加锁的方式来进行count的统计
6. 因为都被锁住，其他线程无法进行其他操作，统计出的count自然很准确







### 为什么Map中使用synchronized而不是ReentrantLock，

因为：synchronized 在1.6之后得到很大的优化

Synchronized 锁 obj 对象头 markwork 的锁标志位--锁对象

重量级锁会造成线程排队（串行执行- CPU在用户态和核心态之间频繁切代价高、效率低)

为了提高效率，不会一开始就使用重量级锁，JVM在内部会根据需要，按如下步骤进行锁的升级

1. 刚开始创建对象时，还没有任何线程竞争，这时候是一种无锁的状态，偏向锁标识位是0，锁状态01
2. 当有一个线程来竞争，升级偏向锁，mark-word记录当前线程ID，这个线程执行不需要任何检查和切换（偏爱这个线程）
3. 当有两个线程来竞争，升级轻量锁，mark-word记录执行哪个线程的锁记录，CAS操作去竞争
4. 多线程竞争，升级重量锁，mark-word指向一个集合，这个集合管理线程的登记和排队

整个过程是不可逆的







### ConcurrentHashMap 应用场景

项目是在缓存一些全局变量，app 版本，首页banner，首页标签















































