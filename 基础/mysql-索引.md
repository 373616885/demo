### 索引

索引：一种高效获取数据的  **排好序** 的 **数据结构**

索引的数据结构：

- 二叉树
- 红黑树
- hash表
- B-Tree（b树）
- B+Tree（b树的变种）

一个数据结构网站：

https://www.cs.usfca.edu/~galles/visualization/Algorithms.html



### MySql 索引有两种   B+Tree 和 HASH 

![](img\20210402114722.png)





```
KEY `index_name` (`name`) USING BTREE

KEY `index_name` (`name`) USING HASH

INDEX `index_name` (`name`)

index和key没有区别(即使有区别，也可以忽略)

index是比较标准的语法

key有primary key，foreign key，UNIQUE KEY
```





### HASH 索引是数组加链表--查找效率最高

直接hash定位，hash冲突一般也很少

缺点：只支持 “  = ”  不支持 “ in ” 和范围查找



### B-Tree （B树）

![](img\20210402120312.png)



叶节点：

每个节点横向扩展（多个--每个都包含key-data数据）

节点中的元素从左到右递增

所有的元素都是不重复的



### B+Tree （B树的变种）

![](img\20210402121041.png)



### B+树和B树的区别

非叶子节点不存储data，只存索引（冗余）

叶子节点包含所有索引数据

叶子节点有指针连接，可以提高区间访问的性能





### MySql 底层索引就是使用B+Tree

MySql 每个节点（页大小）都是16K左右 （innodb_page_size ）

```
SHOW GLOBAL STATUS like 'Innodb_page_size';

Variable_name	    Value
Innodb_page_size	16384
```

页大小：就是叶子节点



### Buffer pool 缓冲池

每次都将页大小（Innodb_page_size 16kb）放到缓冲池中--算法LRU 淘汰最少用原则





### 为什么要用B+Tree

因为：

b-tree 红黑树等每个节点一个数据（key-date）--一层就只能存少量的数据，千万数据的时候 ，会很多层（一层一次IO）

b+tree 上层节点都是不包含date的，只存key--3层就可以存千万的数据



b+tree 底层叶节点就是数据按排序好的,上面几层都是冗余的

MySql 每层叶节点 16kb

冗余节点结构：

主键(索引值 id )+下一个地址 --- 主键+下一个地址 .......

一般主键 bigInt 8字节       下一个地址：mysql底层：6个自己

16kb / (8+6) = 1142

底层叶节点结构：

主键(索引值 id )+ data (一条数据) = 数据算1k吧       

16kb /1K = 16

3层：2层冗余 + 1层数据

1142 * 1142 *16 = 20 866 624 （2千多万）

B+Tree 3层就可以存2千多万条数据

![](img\20210402124354.png)



mysql 分库不仅要看数据量还要看数据大小

主键的大小和数据的大小 （2层1304164 个数据 16kb）1304164 *16kb = 2G多空间

所以单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表



### MySql查询过程

查询有索引

找到第一层的放到内存--内存中找到下层的地址（**已排好序直接比较大小--内部二分法**）

第二层的节点找到最低层叶节点

低层叶节点就可以找到数据（叶子节点包含所有索引数据）





### mysql 存储引擎 

存储引擎是修饰表的（不是修饰数据库的）



### MyISAM 存储引擎

![](img\20210403012217.png)

在date目录下有三个文件  

- frm 表结构
- MYD data数据
- MYI 索引文件 

MyISAM 非聚集索引：（索引和数据文件分开）

- MyISAM B+树主键索引和辅助索引尾叶子节点都是 索引值和数据文件的地址指针

MYISAM 查询过程

- 如果有索引 -- 去MYI去找（B+树查询找法--MYI存储的是数据的地址指针）到地址指针
- 然后通过地址指针-去MYD文件里找数据

与Innodb相比 多了一步通过地址指针去MYD文件找数据，多一次IO，性能略差

早期的版本才支持--MyISAM 查询性能差一些，所以早期版本才支持



### InnoDB 存储引擎

![](img\20210403013038.png)

在在date目录下有两个文件  

- frm 表结构
- idb 数据和索引都放到这个文件里

InnoDB 聚集索引：（索引和数据都在一个文件里面）

- InnoDB B+树主键索引叶子节点就是数据文件（尾叶子节点）
- 辅助索引（非主键索引）叶子节点是主键值

InnoDB 查询过程：

- 如果是辅助索引 -- 直接在辅助索引里找到主键（B+树查询找法）
- 然后通过--主键值找到数据（B+树查询找法）
- 如果是主键索引-- 直接通过主键值找到数据

与 MyISAM 相比 InnoDB 找数据--都在一个文件里面，少了一次IO，所以现在的表基本都是 InnoDB 的表

当然 InnoDB 支持事务是也是一方面



### 聚集索引和非聚集索引的区别

聚集索引：索引和数据都在一个文件里

缺点：

修改主键和在插入新记录的时候

如果不是在尾部，数据行必须移动到新的位置，索引此时会重排，会造成很大的资源浪费

非聚集索引：索引和数据分开放

MyISAM 用非聚集索引：

- B+树主键索引和辅助索引叶子节点都是存储数据文件的地址指针

InnoDB 用聚集索引：

- B+树主键索引叶子节点存储数据文件
- 辅助索引叶子节点存储主键值

MyISAM查询过程：

- 通过 **MYI** 文件找到地址指针
- 然后地址指针到 **MYD** 文件找到数据

InnoDB查询过程：

- 如果是辅助索引 -- 直接在辅助索引里找到主键（B+树查询找法）
- 然后通过--主键值找到数据（B+树查询找法）
- 如果是主键索引-- 直接通过主键值找到数据



### 面试重点

为什么 InnoDB 表必须建主键，并且推荐使用整型自增

#### 为什么表必须建主键

InnoDB 表的表如果没有主键MySql会找一个唯一列作为主键

如果没有就自己生成一列

没有主键增加MySql负担和空间浪费

所以InnoDB表必须建主键

#### 为什么推荐使用整型

UUID 作为主键-- 节点上为了排序会转成ASCII码，作为比较（内部二分法）--与整型相比没整型快

还有最主要的（16kb）的节点上存储的东西更少了（最终导致的存储数据也少了）---浪费SSD硬盘空间

#### 为什么推荐使用自增

如果是自增--B+Tree 会将数据放到尾部--自增以排好序

不会产生叶分裂

如果不是连续的插入数据的时候，当数据大于一个叶节点16kb--就会产生叶分裂

在这个叶节点中间产生一个16kb的叶节点，可能造成 一个16kb叶节点 ,就一个数据的情况，此时内部可能会造成索引重排





#### B树和B+树的区别

B树的叶节点（尾叶节点）没有指针相连

B+树的叶节点有指针相连---因为有了节点有指针相连才支持范围查询

B树的节点存储data数据

B+树的叶节点才存储data数据，非叶子节点都是冗余的--因为这3层就可以存储2千多万的数据



#### 什么情况下mysql索引会失效

索引失效：一般都是针对联合索引



联合索引: a_b 

a 的值是有序的

b的值是无序的，只有在a相等的情况下才有序

所以索引要遵循最左前缀匹配原则



在联合索引的范围查询的情况下会导致 mysql索引，可以使用 force_index() 强制使用索引

在 from 表名 force_index(字段) where a= a

索引：：a_b_c

a的范围查询 a> ?  

a**  辅助索引找到了大于a数据的主键 ，但通过这些主键，后面的数据都要经历回表

这时候，mysql 会认为全表扫描比走索引更好



a like ‘%5%’ like 情况也一样





### 阿里规范关于建主键的

【强制】表必备三字段：id, create_time, update_time。

说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。create_time, update_time

的类型均为 datetime 类型，前者现在时表示主动式创建，后者过去分词表示被动式更新

【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。

说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。





### 联合索引

如果有超过5个索引建议使用联合索引

**索引识别度高的放到前面**

- index a_b    a能过滤的数据多就a放前面

where执行顺序是从左往右执行的

遵守原则：

- 排除越多数据的条件放在第一个
- mysql 有优化正常情况没有影响
- 联合索引是有影响的

联合索引的数据结构：

- 第一列排序然后到第二个字段最后第三个这种顺序


![](img\20210403022358.png)



### 索引最左前缀原则

联合索引: a_b 

a 的值是有序的

b 的值是无序的，只有在a相等的情况下才有序，无法在有序的B+tree找到有序的值（通过二分法去查找）

所以索引要遵循最左前缀匹配原则 ，直接使用 b 是无法使用索引的



单索引：a

where a=?    ,where a> ?   辅助索引不会走索引，a是主键才会走索引



索引：a_b_c

where a=? 走索引   1**  

where b=? 不走索引 

where a>? 不走索引	a** 辅助索引找到了大于a数据的主键 ，但通过这些主键，后面的数据都要经历回表

这时候，mysql 会认为全表扫描比走索引更好

where a>?  b=1 不走索引	a** 辅助索引找到了大于a数据的主键 ，后面的数据 b 是无序的，费非叶子节点上也是无序的

根本无通过二分法去查找，只能将后面全扫描，然后数据还有回表

where a=?  b=1 走索引  a相等的情况下b值是有序的

where a=?  and b>? and c =?  走索引 ab 因为b是范围 ，没办法根据b，去做c的排序







正例：where a=? and b=? order by c; 索引：a_b_c

反例：where  b=?  索引：a_b_c  不是前缀

陷阱：索引：a_b_c     where b=？and c=? and a=? 这个也会用到索引

因为：mysql的sql引擎会优化成 where a=？and b=? and c=?



### 在order by 的场景，请注意利用索引的有序性

如：WHERE a>10 ORDER BY b; 无法排序

索引 a_b    a 存在范围查询，那么索引有序性无法利用



### 利用覆盖索引来进行查询操作，避免回表

说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这

个目录就是起到覆盖索引的作用。



### 回表

辅助索引：找到了主键，然后在通过主键去找数据--这就是回表



























































































































