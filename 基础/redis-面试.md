### redis是单线程还是多线程

redis5.0之前是  单线程worker 

单worker线程：即处理IO网络请求（TCP），也操作内存（对内存的操作）

![](img\20210408223600.png)



![](img\20210408224755.png)



redis6.0之后  单线程worker 不处理IO网络请求（TCP），只操作内存

IO网络请求有专门的IO子线程

![](img\20210408230158.png)



![](img\20210408231039.png)



redis6.0之后是   IO网络请求有专门的IO子线程   性能更好





### Redis缓存数据机制

redis 保存数据磁盘有两种方式，两种数据文件格式

AOF:  记录会以append追加到AOF文件里面去，中间的操作过程也追加到AOF文件里

   	   最终有效的是最后的数据--过程中的数据是不可取的，AOF不断变大，

​          超过设置的阈值（64M）就会rewrite

​          rewrite作用将过程化的数据都去掉，只保留最终的数据

​		 AOF文件就会瘦身变小

​         AOF文件大，数据不易丢失，恢复慢，耗性能

RDB：某个时间点整个内存的快照--数据有丢失

​       RDB 文件小，数据易丢失，恢复快，性能较好



redis4.0 之后提供一个混合持久化方式

这是推荐的使用方式：

持久化文件既有RDB也有AOF

当AOF，rewrite的时候，删除整个文件，保存RDB，然后在后面append , AOF

整个文件头是RDB后面都是追加的AOF



### Redis 线程模型

reids 基于Reactor （响应式）模式开发的网络事件处理器，单线程的，IO多路复用



###  Redis为什么快

1. 纯内存操作
2. 网络IO请求基于非阻塞的IO多路复用
3. worker单线程避免的多线程的频繁上下文切换



### Redis 单线程有什么缺点

会产生阻塞，在高并发下不应该存储大key，大value

大key，大value ，使用异步处理方案，提高带宽，多主同步



### 缓存雪崩

同一时间大面积缓存失效

解决：

1. 缓存加上随机数-错开



### 缓存穿透

缓存和数据库中都没有的数据，例如：id为“-1”

解决：

1. 接口层增加数据校验
2. 取不到的数据也缓存
3. 布隆过滤器



### 缓存击穿

缓存时间到期，大量并发过来

解决：

1. 加锁，设置缓存的时候加锁



###  缓存问题

设置热点数据永远不过期，异步去修改缓存



### 内存淘汰策略

volatile-lru 

已设置过期时间的数据集中挑选最近最少使用的数据淘汰 

volatile-ttl 

已设置过期时间的数据集中挑选将要过期的数据淘汰

allkeys-lru

从数据集中挑选最近最少使用的数据淘汰

allkeys-random

从数据集中任意选择数据淘汰 

no-enviction

不淘汰任何数据，不可写入任何数据集，所有引起申请内存的命令会报错

















​          



































